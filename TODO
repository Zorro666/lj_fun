To be done:

** Tasks
** unit tests for the unit test layer
** unit tests the basic string functions 
* need a memory allocation layer : LJ_memAlloc, LJ_memFree + support for fixed size pools, stacks, random pools
** unit tests for the memory allocation layer
* need a maths layer : LJ_maths
** unit tests for the maths layer
* sort out debug var interface to engine - its own input handling, toggle on/off
* add debug graphics layer to LJ_LibDebug (just like good old CoreDebug yeah rose tinted glasses)
* implement a base LJ_LibGraphics (2D graphics, texture handling)

** Building Process

** Code Intentions
* should LJ_LibEngine be all the engine libs compiled into a behemoth (kind of defeats the purpose but might be nice)
* use SDL as base engine functionality but encapsulate it away so it doesn't appear in any game code and only in root low-level engine files
* task based system manager
* write new features as tasks (microthreads)
* explore AI ideas using broadcasting control nodes and queues
* dynamic avoidance using repulsion forces
* static route finding - nav meshes (my favourite)
* GUI system - widgets/windows all in raw code
* 2D editor layout and editing system for AI fun
* 2D editor layout system - visual scripting style
* 2D visual debugging tools for AI fun
* more debug features in libdebug - real-time host<->app connection
* implement core engine libs as required: libcommon (file, types, maths, memory)
* tool to make a mega header file as the public header for each library -> a public (auto-generated .h) and a .a file
* keep strong independence between libs - only 1 way dependency e.g. libdebug depends on libcommon BUT libcommon cannot depend on libdebug

** Contentious Issues
* don't use any native types have all types pre type def'ed e.g. LJint32, LJuint32, LJint, LJuint, LJfloat etc.

** Long Term Plans
* get a toolchain up and running support 3D engine
* get exporting from Maya going if possible
* shaders even in 2D

